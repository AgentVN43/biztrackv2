// const { v4: uuidv4 } = require("uuid");
// const InventoryModel = require("./inventory.model"); // ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ r√µ r√†ng h∆°n
// const ProductModel = require("../../modules/product/product.model"); // Gi·∫£ ƒë·ªãnh ƒë∆∞·ªùng d·∫´n ƒë·∫øn ProductModel
// const ProductService = require("../../modules/product/product.service"); // ‚úÖ Import ProductService

// const InventoryService = {
//   /**
//    * T·∫°o b·∫£n ghi t·ªìn kho m·ªõi.
//    * @param {Object} data - D·ªØ li·ªáu t·ªìn kho.
//    * @param {Function} callback - Callback function.
//    */
//   createInventory: async (data, callback) => {
//     try {
//       const inventory = {
//         inventory_id: uuidv4(),
//         ...data,
//       };

//       const existing = await InventoryModel.findByProductAndWarehouse(
//         data.product_id,
//         data.warehouse_id
//       );

//       if (existing) {
//         return callback(
//           new Error(
//             "Inventory already exists for this product in the warehouse"
//           )
//         );
//       }

//       const result = await InventoryModel.create(inventory);
//       callback(null, result);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: createInventory - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * L·∫•y t·∫•t c·∫£ c√°c b·∫£n ghi t·ªìn kho.
//    * @param {Function} callback - Callback function.
//    */
//   getAllInventories: async (callback) => {
//     try {
//       const inventories = await InventoryModel.findAll();
//       callback(null, inventories);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: getAllInventories - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * L·∫•y b·∫£n ghi t·ªìn kho theo ID.
//    * @param {string} id - ID t·ªìn kho.
//    * @param {Function} callback - Callback function.
//    */
//   getInventoryById: async (id, callback) => {
//     try {
//       const inventory = await InventoryModel.findById(id);
//       callback(null, inventory);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: getInventoryById - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * X√≥a b·∫£n ghi t·ªìn kho theo ID.
//    * @param {string} id - ID t·ªìn kho.
//    * @param {Function} callback - Callback function.
//    */
//   deleteInventory: async (id, callback) => {
//     try {
//       const result = await InventoryModel.deleteById(id);
//       callback(null, result);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: deleteInventory - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * C·∫≠p nh·∫≠t b·∫£n ghi t·ªìn kho.
//    * @param {string} inventory_id - ID t·ªìn kho.
//    * @param {Object} data - D·ªØ li·ªáu c·∫≠p nh·∫≠t.
//    * @param {Function} callback - Callback function.
//    */
//   updateInventory: async (inventory_id, data, callback) => {
//     try {
//       const result = await InventoryModel.update(inventory_id, data);
//       callback(null, result);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: updateInventory - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * L·∫•y t·ªìn kho theo ID kho.
//    * @param {string} id - ID kho.
//    * @param {Function} callback - Callback function.
//    */
//   getByWareHouseId: async (id, callback) => {
//     try {
//       const inventories = await InventoryModel.findByWareHouseId(id);
//       callback(null, inventories);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: getByWareHouseId - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * L·∫•y t·∫•t c·∫£ t·ªìn kho theo ID kho (tr√πng l·∫∑p v·ªõi getByWareHouseId, gi·ªØ l·∫°i n·∫øu c√≥ m·ª•c ƒë√≠ch kh√°c).
//    * @param {string} id - ID kho.
//    * @param {Function} callback - Callback function.
//    */
//   getAllInventoriesByWarehouse: async (id, callback) => {
//     try {
//       const inventories = await InventoryModel.findByWareHouseId(id);
//       callback(null, inventories);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: getAllInventoriesByWarehouse - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * TƒÉng s·ªë l∆∞·ª£ng t·ªìn kho.
//    * @param {string} product_id - ID s·∫£n ph·∫©m.
//    * @param {string} warehouse_id - ID kho.
//    * @param {number} quantity - S·ªë l∆∞·ª£ng c·∫ßn tƒÉng.
//    * @param {Function} callback - Callback function.
//    */
//   increaseQuantity: async (product_id, warehouse_id, quantity, callback) => {
//     try {
//       // S·ª≠ d·ª•ng updateQuantitySimple ho·∫∑c updateQuantity t√πy thu·ªôc v√†o logic mong mu·ªën
//       const result = await InventoryModel.updateQuantitySimple(
//         product_id,
//         warehouse_id,
//         quantity
//       );
//       callback(null, result);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: increaseQuantity - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * TƒÉng t·ªìn kho t·ª´ ƒë∆°n mua h√†ng.
//    * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng mua.
//    * @param {string} warehouse_id - ID kho.
//    * @param {Function} callback - Callback function.
//    */
//   increaseStockFromPurchaseOrder: async (
//     orderDetails,
//     warehouse_id,
//     callback
//   ) => {
//     try {
//       if (!orderDetails || orderDetails.length === 0) {
//         return callback(new Error("Kh√¥ng c√≥ orderDetails"));
//       }

//       for (const { product_id, quantity } of orderDetails) {
//         // C·∫≠p nh·∫≠t products
//         // await ProductService.updateStockFields(
//         //   product_id,
//         //   quantity, // stock += quantity
//         //   0, // reserved_stock gi·ªØ nguy√™n
//         //   quantity // available_stock += quantity
//         // );

//         // C·∫≠p nh·∫≠t inventories
//         const existing = await InventoryModel.findByProductAndWarehouse(
//           product_id,
//           warehouse_id
//         );

//         if (existing) {
//           await InventoryModel.updateQuantity(
//             product_id,
//             warehouse_id,
//             quantity
//           );
//         } else {
//           await InventoryModel.create({
//             inventory_id: uuidv4(),
//             product_id,
//             warehouse_id,
//             quantity,
//             reserved_stock: 0,
//             available_stock: quantity,
//           });
//         }
//       }
//       callback(null);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: increaseStockFromPurchaseOrder - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * Gi·ªØ t·ªìn kho khi t·∫°o ƒë∆°n h√†ng.
//    * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
//    * @param {string} warehouse_id - ID kho.
//    * @param {Function} callback - Callback function.
//    */
//   reserveStockFromOrderDetails: async (
//     orderDetails,
//     warehouse_id,
//     callback
//   ) => {
//     try {
//       if (!orderDetails || orderDetails.length === 0) {
//         return callback(null); // Kh√¥ng c√≥ chi ti·∫øt ƒë·ªÉ x·ª≠ l√Ω
//       }

//       for (const { product_id, quantity } of orderDetails) {
//         await InventoryModel.updateReservedAndAvailable(
//           product_id,
//           warehouse_id,
//           quantity, // +reserved
//           -quantity // -available
//         );
//       }
//       callback(null);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: reserveStockFromOrderDetails - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * Gi·∫£i ph√≥ng t·ªìn kho ƒë√£ ƒë·∫∑t tr∆∞·ªõc khi h·ªßy ƒë∆°n h√†ng.
//    * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
//    * @param {string} warehouse_id - ID kho.
//    * @param {Function} callback - Callback function.
//    */
//   releaseReservedStock: async (orderDetails, warehouse_id, callback) => {
//     try {
//       if (!orderDetails || orderDetails.length === 0) {
//         return callback(null); // Kh√¥ng c√≥ chi ti·∫øt ƒë·ªÉ x·ª≠ l√Ω
//       }

//       for (const { product_id, quantity } of orderDetails) {
//         await InventoryModel.updateReservedAndAvailable(
//           product_id,
//           warehouse_id,
//           -quantity, // -reserved
//           quantity // +available
//         );
//       }
//       callback(null);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: releaseReservedStock - Error:",
//         error
//       );
//       callback(error);
//     }
//   },

//   /**
//    * X√°c nh·∫≠n t·ªìn kho ƒë·∫∑t tr∆∞·ªõc (chuy·ªÉn t·ª´ reserved sang sold).
//    * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
//    * @param {string} warehouse_id - ID kho.
//    * @returns {Promise<void>} Promise gi·∫£i quy·∫øt khi ho√†n th√†nh ho·∫∑c t·ª´ ch·ªëi n·∫øu c√≥ l·ªói.
//    */
//   confirmStockReservation: async (orderDetails, warehouse_id) => {
//     try {
//       for (const { product_id, quantity } of orderDetails) {
//         await InventoryModel.confirmReservation(
//           product_id,
//           warehouse_id,
//           quantity
//         );
//       }
//       // Kh√¥ng c·∫ßn resolve/reject ·ªü ƒë√¢y v√¨ n√≥ ƒë∆∞·ª£c g·ªçi t·ª´ order.service.update
//       // v√† s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi try/catch c·ªßa h√†m g·ªçi.
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: confirmStockReservation - Error:",
//         error
//       );
//       throw error; // N√©m l·ªói ƒë·ªÉ ƒë∆∞·ª£c b·∫Øt b·ªüi order.service.update
//     }
//   },

//   /**
//    * Gi·∫£m t·ªìn kho t·ª´ chi ti·∫øt ƒë∆°n h√†ng (sau khi ƒë∆°n h√†ng ƒë∆∞·ª£c ho√†n t·∫•t).
//    * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
//    * @param {string} warehouse_id - ID kho.
//    * @param {Function} callback - Callback function.
//    */
//   decreaseStockFromOrderDetails: async (
//     orderDetails,
//     warehouse_id,
//     callback
//   ) => {
//     try {
//       if (!orderDetails || orderDetails.length === 0) {
//         return callback(new Error("Kh√¥ng c√≥ s·∫£n ph·∫©m trong ƒë∆°n h√†ng"));
//       }

//       for (const { product_id, quantity } of orderDetails) {
//         // Gi·∫£m t·ªìn kho: stock -= quantity
//         await ProductModel.updateStockFromOrderDetails(
//           product_id,
//           -quantity, // ‚ö†Ô∏è L∆∞u √Ω l√† s·ªë √¢m ƒë·ªÉ gi·∫£m
//           0, // reserved_stock gi·ªØ nguy√™n (n·∫øu c·∫ßn c√≥ th·ªÉ tƒÉng)
//           -quantity // available_stock -= quantity
//         );

//         // C·∫≠p nh·∫≠t inventories
//         const existing = await InventoryModel.findByProductAndWarehouse(
//           product_id,
//           warehouse_id
//         );

//         if (existing) {
//           await InventoryModel.updateQuantitySimple(
//             // S·ª≠ d·ª•ng updateQuantitySimple
//             product_id,
//             warehouse_id,
//             -quantity // gi·∫£m t·ªìn kho theo warehouse
//           );
//         } else {
//           return callback(
//             new Error(
//               `Kh√¥ng t√¨m th·∫•y t·ªìn kho c·ªßa s·∫£n ph·∫©m ${product_id} t·∫°i kho ${warehouse_id}`
//             )
//           );
//         }
//       }
//       callback(null);
//     } catch (error) {
//       //console.error(
//         "üöÄ ~ inventory.service.js: decreaseStockFromOrderDetails - Error:",
//         error
//       );
//       callback(error);
//     }
//   },
// };

// module.exports = InventoryService;
// inventory.service.js
const { v4: uuidv4 } = require("uuid");
const InventoryModel = require("./inventory.model"); // ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ r√µ r√†ng h∆°n
const ProductModel = require("../../modules/product/product.model"); // Gi·∫£ ƒë·ªãnh ƒë√¢y l√† ProductModel ch·ª©a logic DB
const ProductEventModel = require("../product_report/product_event.model");

const InventoryService = {
  /**
   * T·∫°o b·∫£n ghi t·ªìn kho m·ªõi.
   * @param {Object} data - D·ªØ li·ªáu t·ªìn kho.
   * @returns {Promise<Object>} Promise gi·∫£i quy·∫øt v·ªõi ƒë·ªëi t∆∞·ª£ng t·ªìn kho ƒë√£ t·∫°o.
   */
  createInventory: async (data) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      const inventory = {
        inventory_id: uuidv4(),
        ...data,
      };

      const existing = await InventoryModel.findByProductAndWarehouse(
        data.product_id,
        data.warehouse_id
      );

      if (existing) {
        throw new Error( // ‚úÖ Thay callback b·∫±ng throw Error
          "Inventory already exists for this product in the warehouse"
        );
      }

      const result = await InventoryModel.create(inventory);
      return result; // ‚úÖ Tr·∫£ v·ªÅ k·∫øt qu·∫£
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: createInventory - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * L·∫•y t·∫•t c·∫£ c√°c b·∫£n ghi t·ªìn kho (c√≥ th·ªÉ ph√¢n trang).
   * @param {number|null} skip - S·ªë b·∫£n ghi b·ªè qua (offset).
   * @param {number|null} limit - S·ªë b·∫£n ghi l·∫•y v·ªÅ.
   * @returns {Promise<Array|{inventories:Array,total:number}>}
   */
  getAllInventories: async (skip = null, limit = null) => {
    try {
      if (skip !== null && limit !== null) {
        const [inventories, total] = await Promise.all([
          InventoryModel.findAll(skip, limit),
          InventoryModel.countAll(),
        ]);
        return { inventories, total };
      } else {
        const inventories = await InventoryModel.findAll();
        return inventories;
      }
    } catch (error) {
      //console.error("üöÄ ~ inventory.service.js: getAllInventories - Error:", error);
      throw error;
    }
  },

  /**
   * L·∫•y b·∫£n ghi t·ªìn kho theo ID.
   * @param {string} id - ID t·ªìn kho.
   * @returns {Promise<Object|null>} Promise gi·∫£i quy·∫øt v·ªõi ƒë·ªëi t∆∞·ª£ng t·ªìn kho ho·∫∑c null.
   */
  getInventoryById: async (id) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      const inventory = await InventoryModel.findById(id);
      return inventory; // ‚úÖ Tr·∫£ v·ªÅ k·∫øt qu·∫£
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: getInventoryById - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * X√≥a b·∫£n ghi t·ªìn kho theo ID.
   * @param {string} id - ID t·ªìn kho.
   * @returns {Promise<Object>} Promise gi·∫£i quy·∫øt v·ªõi k·∫øt qu·∫£ x√≥a.
   */
  deleteInventory: async (id) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      const result = await InventoryModel.deleteById(id);
      return result; // ‚úÖ Tr·∫£ v·ªÅ k·∫øt qu·∫£
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: deleteInventory - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * C·∫≠p nh·∫≠t b·∫£n ghi t·ªìn kho.
   * @param {string} inventory_id - ID t·ªìn kho.
   * @param {Object} data - D·ªØ li·ªáu c·∫≠p nh·∫≠t.
   * @returns {Promise<Object>} Promise gi·∫£i quy·∫øt v·ªõi k·∫øt qu·∫£ c·∫≠p nh·∫≠t.
   */
  updateInventory: async (inventory_id, data) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      const result = await InventoryModel.update(inventory_id, data);
      return result; // ‚úÖ Tr·∫£ v·ªÅ k·∫øt qu·∫£
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: updateInventory - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * L·∫•y t·ªìn kho theo warehouse_id, c√≥ th·ªÉ ph√¢n trang.
   * @param {string} warehouse_id
   * @param {number|null} skip
   * @param {number|null} limit
   * @returns {Promise<Array|{inventories:Array,total:number}>}
   */
  getByWareHouseId: async (warehouse_id, skip = null, limit = null) => {
    try {
      if (skip !== null && limit !== null) {
        const [inventories, total] = await Promise.all([
          InventoryModel.findByWareHouseIdWithPagination(warehouse_id, skip, limit),
          InventoryModel.countByWareHouseId(warehouse_id),
        ]);
        return { inventories, total };
      } else {
        const inventories = await InventoryModel.findByWareHouseId(warehouse_id);
        return inventories;
      }
    } catch (error) {
      //console.error("üöÄ ~ inventory.service.js: getByWareHouseId - Error:", error);
      throw error;
    }
  },

  /**
   * L·∫•y t·∫•t c·∫£ t·ªìn kho theo ID kho (tr√πng l·∫∑p v·ªõi getByWareHouseId, gi·ªØ l·∫°i n·∫øu c√≥ m·ª•c ƒë√≠ch kh√°c).
   * @param {string} id - ID kho.
   * @returns {Promise<Array<Object>>} Promise gi·∫£i quy·∫øt v·ªõi danh s√°ch t·ªìn kho theo kho.
   */
  getAllInventoriesByWarehouse: async (id) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      const inventories = await InventoryModel.findByWareHouseId(id);
      return inventories; // ‚úÖ Tr·∫£ v·ªÅ k·∫øt qu·∫£
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: getAllInventoriesByWarehouse - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * TƒÉng s·ªë l∆∞·ª£ng t·ªìn kho.
   * @param {string} product_id - ID s·∫£n ph·∫©m.
   * @param {string} warehouse_id - ID kho.
   * @param {number} quantity - S·ªë l∆∞·ª£ng c·∫ßn tƒÉng.
   * @returns {Promise<Object>} Promise gi·∫£i quy·∫øt v·ªõi k·∫øt qu·∫£ c·∫≠p nh·∫≠t.
   */
  increaseQuantity: async (product_id, warehouse_id, quantity) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      // S·ª≠ d·ª•ng updateQuantitySimple ho·∫∑c updateQuantity t√πy thu·ªôc v√†o logic mong mu·ªën
      const result = await InventoryModel.updateQuantitySimple(
        product_id,
        warehouse_id,
        quantity
      );
      return result; // ‚úÖ Tr·∫£ v·ªÅ k·∫øt qu·∫£
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: increaseQuantity - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * TƒÉng t·ªìn kho t·ª´ ƒë∆°n mua h√†ng.
   * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng mua.
   * @param {string} warehouse_id - ID kho.
   * @returns {Promise<void>} Promise gi·∫£i quy·∫øt khi ho√†n th√†nh ho·∫∑c t·ª´ ch·ªëi n·∫øu c√≥ l·ªói.
   */
  increaseStockFromPurchaseOrder: async (orderDetails, warehouse_id) => {
    // ƒê√£ s·ª≠a ·ªü l·∫ßn tr∆∞·ªõc
    try {
      if (!orderDetails || orderDetails.length === 0) {
        return;
      }

      for (const { product_id, quantity } of orderDetails) {
        // C·∫≠p nh·∫≠t products (n·∫øu c·∫ßn, ƒë·∫£m b·∫£o ProductService.updateStockFields tr·∫£ v·ªÅ Promise)
        // await ProductService.updateStockFields(
        //   product_id,
        //   quantity, // stock += quantity
        //   0, // reserved_stock gi·ªØ nguy√™n
        //   quantity // available_stock += quantity
        // );

        // C·∫≠p nh·∫≠t inventories
        const existing = await InventoryModel.findByProductAndWarehouse(
          product_id,
          warehouse_id
        );

        if (existing) {
          await InventoryModel.update(product_id, warehouse_id, quantity);
        } else {
          // T·∫°o inventory record m·ªõi - total_value s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông l·∫•y t·ª´ products.cost_price
          await InventoryModel.create({
            inventory_id: uuidv4(),
            product_id,
            warehouse_id,
            quantity,
            reserved_stock: 0,
            available_stock: quantity,
          });
        }
      }
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: increaseStockFromPurchaseOrder - Error:",
        error
      );
      throw error;
    }
  },

  /**
   * Gi·ªØ t·ªìn kho khi t·∫°o ƒë∆°n h√†ng.
   * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
   * @param {string} warehouse_id - ID kho.
   * @returns {Promise<void>} Promise gi·∫£i quy·∫øt khi ho√†n th√†nh ho·∫∑c t·ª´ ch·ªëi n·∫øu c√≥ l·ªói.
   */
  reserveStockFromOrderDetails: async (orderDetails, warehouse_id) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      if (!orderDetails || orderDetails.length === 0) {
        return; // ‚úÖ Kh√¥ng g·ªçi callback, ch·ªâ return
      }

      for (const { product_id, quantity } of orderDetails) {
        await InventoryModel.updateReservedAndAvailable(
          product_id,
          warehouse_id,
          quantity, // +reserved
          -quantity // -available
        );
      }
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: reserveStockFromOrderDetails - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * Gi·∫£i ph√≥ng t·ªìn kho ƒë√£ ƒë·∫∑t tr∆∞·ªõc khi h·ªßy ƒë∆°n h√†ng.
   * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
   * @param {string} warehouse_id - ID kho.
   * @returns {Promise<void>} Promise gi·∫£i quy·∫øt khi ho√†n th√†nh ho·∫∑c t·ª´ ch·ªëi n·∫øu c√≥ l·ªói.
   */
  releaseReservedStock: async (orderDetails, warehouse_id) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      if (!orderDetails || orderDetails.length === 0) {
        return; // ‚úÖ Kh√¥ng g·ªçi callback, ch·ªâ return
      }

      for (const { product_id, quantity } of orderDetails) {
        await InventoryModel.updateReservedAndAvailable(
          product_id,
          warehouse_id,
          -quantity, // -reserved
          quantity // +available
        );
      }
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: releaseReservedStock - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  /**
   * X√°c nh·∫≠n t·ªìn kho ƒë·∫∑t tr∆∞·ªõc (chuy·ªÉn t·ª´ reserved sang sold).
   * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
   * @param {string} warehouse_id - ID kho.
   * @returns {Promise<void>} Promise gi·∫£i quy·∫øt khi ho√†n th√†nh ho·∫∑c t·ª´ ch·ªëi n·∫øu c√≥ l·ªói.
   */
  confirmStockReservation: async (orderDetails, warehouse_id) => {
    // ƒê√£ s·ª≠a ·ªü l·∫ßn tr∆∞·ªõc
    try {
      for (const { product_id, quantity } of orderDetails) {
        await InventoryModel.confirmReservation(
          product_id,
          warehouse_id,
          quantity
        );
      }
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: confirmStockReservation - Error:",
        error
      );
      throw error;
    }
  },

  /**
   * Gi·∫£m t·ªìn kho t·ª´ chi ti·∫øt ƒë∆°n h√†ng (sau khi ƒë∆°n h√†ng ƒë∆∞·ª£c ho√†n t·∫•t).
   * @param {Array<Object>} orderDetails - Chi ti·∫øt ƒë∆°n h√†ng.
   * @param {string} warehouse_id - ID kho.
   * @returns {Promise<void>} Promise gi·∫£i quy·∫øt khi ho√†n th√†nh ho·∫∑c t·ª´ ch·ªëi n·∫øu c√≥ l·ªói.
   */
  decreaseStockFromOrderDetails: async (orderDetails, warehouse_id) => {
    // ‚úÖ B·ªè tham s·ªë `callback`
    try {
      if (!orderDetails || orderDetails.length === 0) {
        throw new Error("Kh√¥ng c√≥ s·∫£n ph·∫©m trong ƒë∆°n h√†ng"); // ‚úÖ Thay callback b·∫±ng throw Error
      }

      for (const { product_id, quantity } of orderDetails) {
        // Gi·∫£m t·ªìn kho: stock -= quantity
        // ƒê·∫£m b·∫£o ProductModel.updateStockFromOrderDetails tr·∫£ v·ªÅ Promise
        await ProductModel.updateStockFromOrderDetails(
          product_id,
          -quantity, // ‚ö†Ô∏è L∆∞u √Ω l√† s·ªë √¢m ƒë·ªÉ gi·∫£m
          0, // reserved_stock gi·ªØ nguy√™n (n·∫øu c·∫ßn c√≥ th·ªÉ tƒÉng)
          -quantity // available_stock -= quantity
        );

        // C·∫≠p nh·∫≠t inventories
        const existing = await InventoryModel.findByProductAndWarehouse(
          product_id,
          warehouse_id
        );

        if (existing) {
          await InventoryModel.updateQuantitySimple(
            product_id,
            warehouse_id,
            -quantity // gi·∫£m t·ªìn kho theo warehouse
          );
        } else {
          throw new Error( // ‚úÖ Thay callback b·∫±ng throw Error
            `Kh√¥ng t√¨m th·∫•y t·ªìn kho c·ªßa s·∫£n ph·∫©m ${product_id} t·∫°i kho ${warehouse_id}`
          );
        }
      }
    } catch (error) {
      console.error(
        "üöÄ ~ inventory.service.js: decreaseStockFromOrderDetails - Error:",
        error
      );
      throw error; // ‚úÖ N√©m l·ªói
    }
  },

  increaseStockManually: async (product_id, warehouse_id, quantity, reason, initiatedByUserId = null) => {
    if (quantity <= 0) {
      throw new Error("S·ªë l∆∞·ª£ng tƒÉng ph·∫£i l·ªõn h∆°n 0.");
    }

    // B∆∞·ªõc 1: Ki·ªÉm tra xem b·∫£n ghi t·ªìn kho ƒë√£ t·ªìn t·∫°i ch∆∞a
    let inventoryRecord = await InventoryModel.findByProductAndWarehouse(
      product_id,
      warehouse_id
    );

    //console.log("inventoryRecord:", inventoryRecord);

    const current_quantity_before = inventoryRecord
      ? inventoryRecord.total_quantity
      : 0;

    //console.log("current_quantity_before:", current_quantity_before);

    let result;
    if (inventoryRecord) {
      // B∆∞·ªõc 2: N·∫øu c√≥, tƒÉng t·ªìn kho b·∫±ng h√†m ƒë√£ c√≥
      result = await InventoryModel.update(product_id, warehouse_id, quantity);
    } else {
      // B∆∞·ªõc 3: N·∫øu ch∆∞a c√≥, t·∫°o b·∫£n ghi t·ªìn kho m·ªõi
      inventory_id = uuidv4();
      result = await InventoryModel.create({
        inventory_id,
        product_id,
        warehouse_id,
        quantity,
      });
    }

    // L·∫•y t·ªìn kho sau khi c·∫≠p nh·∫≠t ƒë·ªÉ c√≥ current_quantity_after
    const updatedInventory = await InventoryModel.findByProductAndWarehouse(
      product_id,
      warehouse_id
    );

    const current_quantity_after = updatedInventory
      ? updatedInventory.total_quantity
      : 0;
    //console.log("current_quantity_after:", current_quantity_after);
    // initiatedByUserId is now passed as parameter
    // B∆∞·ªõc 4: Ghi l·∫°i l·ªãch s·ª≠ ƒëi·ªÅu ch·ªânh v√†o inventory_adjustments
    const adjustmentResult = await InventoryModel.recordAdjustment({
      product_id,
      warehouse_id,
      quantity_changed: quantity, // S·ªë l∆∞·ª£ng thay ƒë·ªïi (lu√¥n l√† s·ªë d∆∞∆°ng)
      adjustment_type: "increase",
      reason,
      adjusted_by: initiatedByUserId,
      current_quantity_before,
      current_quantity_after,
    });

    // B∆∞·ªõc 5: Ghi l·∫°i s·ª± ki·ªán v√†o product_events
    const adjustment_id = adjustmentResult.adjustment_id; // L·∫•y ID c·ªßa adjustment v·ª´a t·∫°o
    await ProductEventModel.recordEvent({
      product_id,
      warehouse_id,
      event_type: "STOCK_ADJUSTMENT_INCREASE",
      quantity_impact: quantity, // S·ªë l∆∞·ª£ng tƒÉng (d∆∞∆°ng)
      transaction_price: null, // Kh√¥ng c√≥ gi√° giao d·ªãch cho ƒëi·ªÅu ch·ªânh kho
      partner_name: null,
      current_stock_after: current_quantity_after,
      reference_id: adjustment_id,
      reference_type: "INVENTORY_ADJUSTMENT",
      description: `ƒêi·ªÅu ch·ªânh tƒÉng kho: ${reason}`,
      initiated_by: initiatedByUserId,
    });

    return updatedInventory;
  },

  decreaseStockManually: async (product_id, warehouse_id, quantity, reason, initiatedByUserId = null) => {
    if (quantity <= 0) {
      throw new Error("S·ªë l∆∞·ª£ng gi·∫£m ph·∫£i l·ªõn h∆°n 0.");
    }

    // B∆∞·ªõc 1: L·∫•y t·ªìn kho hi·ªán t·∫°i ƒë·ªÉ ki·ªÉm tra
    const currentInventory = await InventoryModel.findByProductAndWarehouse(
      product_id,
      warehouse_id
    );

    //console.log("currentInventory:",currentInventory)

    if (!currentInventory) {
      throw new Error("Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m trong kho n√†y.");
    }

    const current_quantity_before = currentInventory
      ? currentInventory.total_quantity
      : 0;

    // B∆∞·ªõc 2: Ki·ªÉm tra ƒë·ªß t·ªìn kho kh·∫£ d·ª•ng ƒë·ªÉ gi·∫£m
    // Gi·∫£m total quantity v√† available stock
    if (currentInventory.available_stock < quantity) {
      throw new Error("Kh√¥ng ƒë·ªß t·ªìn kho kh·∫£ d·ª•ng ƒë·ªÉ gi·∫£m.");
    }

    // B∆∞·ªõc 3: Gi·∫£m t·ªìn kho b·∫±ng h√†m m·ªõi
    await InventoryModel.decreaseQuantityAndAvailableStock(
      product_id,
      warehouse_id,
      quantity
    );

    // B∆∞·ªõc 4: Ghi l·∫°i l·ªãch s·ª≠ ƒëi·ªÅu ch·ªânh (R·∫§T QUAN TR·ªåNG)
    // V√≠ d·ª•: await InventoryAdjustmentModel.recordAdjustment(product_id, warehouse_id, quantity, 'decrease', reason);
    // (B·∫°n c·∫ßn t·∫°o InventoryAdjustmentModel v√† h√†m recordAdjustment t∆∞∆°ng ·ª©ng)

    // Sau khi c·∫≠p nh·∫≠t, l·∫•y l·∫°i b·∫£n ghi t·ªìn kho ƒë·ªÉ tr·∫£ v·ªÅ d·ªØ li·ªáu m·ªõi nh·∫•t
    const updatedInventory = await InventoryModel.findByProductAndWarehouse(
      product_id,
      warehouse_id
    );
    const current_quantity_after = updatedInventory
      ? updatedInventory.total_quantity
      : 0;

      // initiatedByUserId is now passed as parameter

    // B∆∞·ªõc 4: Ghi l·∫°i l·ªãch s·ª≠ ƒëi·ªÅu ch·ªânh v√†o inventory_adjustments
    const adjustmentResult = await InventoryModel.recordAdjustment({
      product_id,
      warehouse_id,
      quantity_changed: quantity,
      adjustment_type: "decrease",
      reason,
      adjusted_by: initiatedByUserId,
      current_quantity_before,
      current_quantity_after,
    });

    // B∆∞·ªõc 5: Ghi l·∫°i s·ª± ki·ªán v√†o product_events
    const adjustment_id = adjustmentResult.adjustment_id; // L·∫•y ID c·ªßa adjustment v·ª´a t·∫°o
    await ProductEventModel.recordEvent({
      product_id,
      warehouse_id,
      event_type: "STOCK_ADJUSTMENT_DECREASE",
      quantity_impact: -quantity, // S·ªë l∆∞·ª£ng gi·∫£m (√¢m)
      transaction_price: null, // Kh√¥ng c√≥ gi√° giao d·ªãch cho ƒëi·ªÅu ch·ªânh kho
      partner_name: null,
      current_stock_after: current_quantity_after,
      reference_id: adjustment_id,
      reference_type: "INVENTORY_ADJUSTMENT",
      description: `ƒêi·ªÅu ch·ªânh gi·∫£m kho: ${reason}`,
      initiated_by: initiatedByUserId,
    });

    return updatedInventory;
  },
};

module.exports = InventoryService;
